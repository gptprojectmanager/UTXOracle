/**
 * UTXOracle Live - Frontend Visualization (T056-T059)
 * 
 * COPIA QUESTO CONTENUTO IN: live/frontend/mempool-viz.js
 * 
 * Implements:
 * - T056: WebSocket client connection
 * - T057: Price display update
 * - T058: Connection status indicator
 * - T059: Reconnection logic with exponential backoff
 */

// =============================================================================
// WebSocket Client (T056, T058, T059)
// =============================================================================

class MempoolWebSocketClient {
    constructor(wsUrl = 'ws://localhost:8000/ws/mempool') {
        this.wsUrl = wsUrl;
        this.ws = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
        this.baseReconnectDelay = 1000; // 1 second
        this.reconnectTimeout = null;
        this.isIntentionallyClosed = false;

        // Callbacks
        this.onMessageCallback = null;
        this.onConnectCallback = null;
        this.onDisconnectCallback = null;
    }

    connect() {
        if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
            console.log('[WebSocket] Already connected or connecting');
            return;
        }

        console.log(`[WebSocket] Connecting to ${this.wsUrl}...`);
        this.isIntentionallyClosed = false;

        try {
            this.ws = new WebSocket(this.wsUrl);

            // T056: Connection opened
            this.ws.onopen = () => {
                console.log('[WebSocket] Connected');
                this.reconnectAttempts = 0;
                
                // T058: Update connection status to green
                if (this.onConnectCallback) {
                    this.onConnectCallback();
                }
            };

            // T056: Message received
            this.ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (this.onMessageCallback) {
                        this.onMessageCallback(data);
                    }
                } catch (err) {
                    console.error('[WebSocket] Failed to parse message:', err);
                }
            };

            // T058: Connection closed
            this.ws.onclose = (event) => {
                console.log('[WebSocket] Disconnected:', event.code, event.reason);
                
                // Update connection status to red
                if (this.onDisconnectCallback) {
                    this.onDisconnectCallback();
                }

                // T059: Auto-reconnect with exponential backoff
                if (!this.isIntentionallyClosed) {
                    this.scheduleReconnect();
                }
            };

            // T058: Connection error
            this.ws.onerror = (error) => {
                console.error('[WebSocket] Error:', error);
            };

        } catch (err) {
            console.error('[WebSocket] Connection failed:', err);
            this.scheduleReconnect();
        }
    }

    // T059: Reconnection logic with exponential backoff
    scheduleReconnect() {
        if (this.isIntentionallyClosed) {
            return;
        }

        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.error('[WebSocket] Max reconnect attempts reached. Giving up.');
            return;
        }

        // Exponential backoff: delay = baseDelay * 2^attempts (capped at 30s)
        const delay = Math.min(
            this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts),
            30000
        );

        this.reconnectAttempts++;
        console.log(`[WebSocket] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);

        this.reconnectTimeout = setTimeout(() => {
            this.connect();
        }, delay);
    }

    disconnect() {
        console.log('[WebSocket] Disconnecting...');
        this.isIntentionallyClosed = true;

        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
        }

        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
    }

    onMessage(callback) {
        this.onMessageCallback = callback;
    }

    onConnect(callback) {
        this.onConnectCallback = callback;
    }

    onDisconnect(callback) {
        this.onDisconnectCallback = callback;
    }
}


// =============================================================================
// Price Display & UI Updates (T057, T058)
// =============================================================================

class UIController {
    constructor() {
        // DOM elements
        this.priceElement = document.getElementById('price');
        this.confidenceElement = document.getElementById('confidence');
        this.confidenceLabelElement = document.getElementById('confidence-label');
        this.connectionStatusElement = document.getElementById('connection-status');
        
        // Stats elements
        this.statReceivedElement = document.getElementById('stat-received');
        this.statFilteredElement = document.getElementById('stat-filtered');
        this.statActiveElement = document.getElementById('stat-active');
        this.statUptimeElement = document.getElementById('stat-uptime');
    }

    // T057: Update price display
    updatePrice(price) {
        if (!price || price <= 0) {
            this.priceElement.textContent = '$--,---';
            return;
        }

        // Format price: $XXX,XXX
        const formatted = '$' + price.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        this.priceElement.textContent = formatted;
    }

    // T057: Update confidence display with color coding
    updateConfidence(confidence) {
        if (confidence === null || confidence === undefined) {
            this.confidenceElement.textContent = '--';
            this.confidenceLabelElement.textContent = '(--)';
            return;
        }

        // Display confidence as 0.0-1.0
        this.confidenceElement.textContent = confidence.toFixed(2);

        // Color-coded labels (from spec.md):
        // >0.8: High (green)
        // 0.5-0.8: Medium (yellow)
        // <0.5: Low (orange)
        let label, colorClass;
        if (confidence >= 0.8) {
            label = 'High';
            colorClass = 'confidence-high';
        } else if (confidence >= 0.5) {
            label = 'Medium';
            colorClass = 'confidence-medium';
        } else {
            label = 'Low';
            colorClass = 'confidence-low';
        }

        this.confidenceLabelElement.textContent = `(${label})`;
        this.confidenceLabelElement.className = `confidence-label ${colorClass}`;
    }

    // T058: Update connection status indicator
    updateConnectionStatus(isConnected) {
        if (isConnected) {
            this.connectionStatusElement.textContent = '● Connected';
            this.connectionStatusElement.className = 'status-indicator status-connected';
        } else {
            this.connectionStatusElement.textContent = '● Disconnected';
            this.connectionStatusElement.className = 'status-indicator status-disconnected';
        }
    }

    updateReconnectingStatus() {
        this.connectionStatusElement.textContent = '● Reconnecting...';
        this.connectionStatusElement.className = 'status-indicator status-reconnecting';
    }

    // Update statistics panel
    updateStats(stats) {
        if (!stats) return;

        this.statReceivedElement.textContent = stats.total_received || 0;
        this.statFilteredElement.textContent = stats.total_filtered || 0;
        this.statActiveElement.textContent = stats.active_in_window || 0;

        // Format uptime as "Xh Ym" or "Xs"
        const uptime = stats.uptime_seconds || 0;
        this.statUptimeElement.textContent = this.formatUptime(uptime);
    }

    formatUptime(seconds) {
        if (seconds < 60) {
            return `${Math.floor(seconds)}s`;
        } else if (seconds < 3600) {
            const minutes = Math.floor(seconds / 60);
            return `${minutes}m`;
        } else {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${minutes}m`;
        }
    }
}


// =============================================================================
// Main Application (T056-T059 Integration)
// =============================================================================

class UTXOracleLive {
    constructor() {
        this.wsClient = new MempoolWebSocketClient();
        this.uiController = new UIController();

        // Setup callbacks
        this.wsClient.onConnect(() => {
            console.log('[App] WebSocket connected');
            this.uiController.updateConnectionStatus(true);
        });

        this.wsClient.onDisconnect(() => {
            console.log('[App] WebSocket disconnected');
            this.uiController.updateConnectionStatus(false);
            this.uiController.updateReconnectingStatus();
        });

        this.wsClient.onMessage((message) => {
            this.handleMempoolUpdate(message);
        });
    }

    start() {
        console.log('[App] Starting UTXOracle Live...');
        this.wsClient.connect();
    }

    stop() {
        console.log('[App] Stopping UTXOracle Live...');
        this.wsClient.disconnect();
    }

    handleMempoolUpdate(message) {
        // Message format (from WebSocketMessage Pydantic model):
        // {
        //   "type": "mempool_update",
        //   "data": {
        //     "price": 113600.50,
        //     "confidence": 0.87,
        //     "transactions": [...],
        //     "stats": { ... },
        //     "timestamp": 1678901234.567
        //   }
        // }

        if (message.type !== 'mempool_update') {
            console.warn('[App] Unknown message type:', message.type);
            return;
        }

        const data = message.data;

        // T057: Update price display
        this.uiController.updatePrice(data.price);

        // T057: Update confidence display
        this.uiController.updateConfidence(data.confidence);

        // Update statistics
        this.uiController.updateStats(data.stats);

        // Log update (throttled to avoid console spam)
        if (Math.random() < 0.1) { // 10% sample
            console.log('[App] Mempool update:', {
                price: data.price,
                confidence: data.confidence,
                active: data.stats?.active_in_window
            });
        }
    }
}


// =============================================================================
// Auto-start on page load
// =============================================================================

let app;

document.addEventListener('DOMContentLoaded', () => {
    console.log('[UTXOracle Live] Initializing...');
    
    app = new UTXOracleLive();
    app.start();

    // Handle page unload
    window.addEventListener('beforeunload', () => {
        app.stop();
    });
});


// =============================================================================
// Exports (for testing)
// =============================================================================

if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        MempoolWebSocketClient,
        UIController,
        UTXOracleLive
    };
}
