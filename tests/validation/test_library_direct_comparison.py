#!/usr/bin/env python3
"""
Direct Comparison: HTML (reference) vs Library (no DuckDB)

This test eliminates DuckDB as a potential source of errors by:
1. Reading HTML file generated by UTXOracle.py (reference)
2. Extracting the exact block range and prices array
3. Fetching the SAME blocks from Bitcoin Core RPC
4. Running UTXOracle_library.py on the same data
5. Comparing results element-by-element

Expected: 0.000000% difference (library should match reference exactly)
"""

import argparse
import json
import logging
import re
import subprocess
import sys
from pathlib import Path
from typing import List, Dict, Optional

from dotenv import load_dotenv

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from UTXOracle_library import UTXOracleCalculator

load_dotenv()

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s"
)


def bitcoin_rpc_call(method: str, params: List = []) -> dict:
    """Call Bitcoin Core RPC using bitcoin-cli"""
    cmd = ["bitcoin-cli", method] + [str(p) for p in params]
    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        raise Exception(f"RPC call failed: {result.stderr}")

    try:
        return json.loads(result.stdout)
    except json.JSONDecodeError:
        return result.stdout.strip()


def parse_html_metadata(html_path: Path) -> Optional[Dict]:
    """
    Extract metadata from UTXOracle HTML file.

    Returns:
        dict with keys: date, first_block, last_block, prices_array, final_price
    """
    try:
        with open(html_path, "r", encoding="utf-8") as f:
            content = f.read()

        # Extract date from filename
        match = re.search(r"UTXOracle_(\d{4}-\d{2}-\d{2})\.html", html_path.name)
        if not match:
            logging.error(f"Could not extract date from {html_path.name}")
            return None
        date_str = match.group(1)

        # Extract block range from HTML
        # UTXOracle.py generates: const heights = [block1, block2, ...]
        heights_match = re.search(r"const heights = \[([0-9, ]+)\]", content)
        if not heights_match:
            logging.error(f"Could not find heights array in {html_path.name}")
            return None

        heights_str = heights_match.group(1)
        heights = [int(h.strip()) for h in heights_str.split(",") if h.strip()]

        if not heights:
            logging.error(f"Empty heights array in {html_path.name}")
            return None

        first_block = min(heights)
        last_block = max(heights)

        # Extract final price from title (NOT from prices array!)
        # The prices array contains only FILTERED intraday prices for the chart
        # The FINAL price is in the title: "UTXOracle Consensus Price $110,537"
        title_match = re.search(r"UTXOracle Consensus Price \$([0-9,]+)", content)
        if not title_match:
            logging.error(f"Could not find consensus price in {html_path.name}")
            return None

        price_str = title_match.group(1).replace(",", "")
        final_price = float(price_str)

        # Also extract prices array for reference (intraday evolution)
        prices_match = re.search(r"const prices = \[([0-9., ]+)\]", content)
        if prices_match:
            prices_str = prices_match.group(1)
            prices_array = [
                float(p.strip()) for p in prices_str.split(",") if p.strip()
            ]
        else:
            prices_array = []

        return {
            "date": date_str,
            "first_block": first_block,
            "last_block": last_block,
            "prices_array": prices_array,
            "final_price": final_price,
            "block_count": last_block - first_block + 1,
        }

    except Exception as e:
        logging.error(f"Error parsing {html_path}: {e}")
        return None


def fetch_transactions_for_blocks(first_block: int, last_block: int) -> List[dict]:
    """
    Fetch all transactions from block range (same as UTXOracle.py would see).
    """
    all_transactions = []
    block_count = last_block - first_block + 1

    logging.info(f"Fetching {block_count} blocks ({first_block}-{last_block})...")

    for i, block_height in enumerate(range(first_block, last_block + 1)):
        if (i + 1) % 50 == 0 or i == 0:
            logging.info(f"  Progress: {i + 1}/{block_count} blocks...")

        # Get block hash
        block_hash = bitcoin_rpc_call("getblockhash", [block_height])

        # Get block with transactions (verbosity=2)
        block = bitcoin_rpc_call("getblock", [block_hash, 2])

        # Add all transactions
        all_transactions.extend(block["tx"])

    logging.info(
        f"✅ Fetched {len(all_transactions)} transactions from {block_count} blocks"
    )

    return all_transactions


def test_single_html_file(html_path: Path) -> Dict:
    """
    Test a single HTML file: compare reference vs library on EXACT same data.

    Args:
        html_path: Path to HTML file generated by UTXOracle.py

    Returns:
        dict with test results
    """
    # Parse HTML metadata
    metadata = parse_html_metadata(html_path)
    if not metadata:
        return {"status": "ERROR", "message": f"Could not parse {html_path.name}"}

    date = metadata["date"]
    first_block = metadata["first_block"]
    last_block = metadata["last_block"]
    reference_price = metadata["final_price"]
    reference_prices_array = metadata["prices_array"]

    logging.info(f"\n{'=' * 80}")
    logging.info(f"Testing {date}")
    logging.info(f"{'=' * 80}")
    logging.info(f"Reference price: ${reference_price:,.2f}")
    logging.info(
        f"Block range: {first_block}-{last_block} ({metadata['block_count']} blocks)"
    )
    logging.info(f"Reference prices array length: {len(reference_prices_array)}")

    # Fetch the EXACT SAME blocks that UTXOracle.py processed
    try:
        transactions = fetch_transactions_for_blocks(first_block, last_block)
    except Exception as e:
        return {
            "status": "ERROR",
            "date": date,
            "message": f"Could not fetch blocks: {e}",
        }

    # Run library on same data
    logging.info("Running UTXOracle_library.py...")
    calc = UTXOracleCalculator()
    result = calc.calculate_price_for_transactions(transactions)

    library_price = result["price_usd"]

    if library_price is None:
        return {
            "status": "ERROR",
            "date": date,
            "reference_price": reference_price,
            "message": "Library returned None",
        }

    # Compare
    diff_amount = abs(reference_price - library_price)
    diff_percent = (diff_amount / reference_price) * 100

    logging.info(f"Library price: ${library_price:,.2f}")
    logging.info(f"Difference: ${diff_amount:,.2f} ({diff_percent:.6f}%)")

    # Verdict
    if diff_percent < 0.01:
        logging.info("✅ PERFECT MATCH (<0.01%)")
        status = "PASS"
    elif diff_percent < 0.1:
        logging.info("✅ VERY GOOD (<0.1%)")
        status = "GOOD"
    else:
        logging.info(f"❌ DIFFERENCE TOO LARGE ({diff_percent:.2f}%)")
        status = "FAIL"

    return {
        "status": status,
        "date": date,
        "reference_price": reference_price,
        "library_price": library_price,
        "diff_amount": diff_amount,
        "diff_percent": diff_percent,
        "tx_count": result["tx_count"],
        "confidence": result["confidence"],
        "block_count": metadata["block_count"],
    }


def main():
    parser = argparse.ArgumentParser(
        description="Direct comparison: HTML (reference) vs Library (no DuckDB)"
    )
    parser.add_argument(
        "--samples",
        type=int,
        default=5,
        help="Number of random HTML files to test (default: 5)",
    )
    parser.add_argument(
        "--date",
        type=str,
        help="Test specific date (YYYY-MM-DD)",
    )
    args = parser.parse_args()

    # Find HTML files
    project_root = Path(__file__).parent.parent.parent
    html_dir = project_root / "historical_data" / "html_files"
    if not html_dir.exists():
        logging.error(f"HTML directory not found: {html_dir}")
        sys.exit(1)

    html_files = sorted(html_dir.glob("UTXOracle_*.html"))
    if not html_files:
        logging.error(f"No HTML files found in {html_dir}")
        sys.exit(1)

    logging.info(f"Found {len(html_files)} HTML files")

    # Select files to test
    if args.date:
        # Test specific date
        target_file = html_dir / f"UTXOracle_{args.date}.html"
        if not target_file.exists():
            logging.error(f"HTML file not found: {target_file}")
            sys.exit(1)
        test_files = [target_file]
    else:
        # Random sample
        import random

        test_files = random.sample(html_files, min(args.samples, len(html_files)))

    # Run tests
    results = []
    for html_file in test_files:
        result = test_single_html_file(html_file)
        results.append(result)

    # Summary
    logging.info(f"\n{'=' * 80}")
    logging.info("SUMMARY")
    logging.info(f"{'=' * 80}")

    pass_count = sum(1 for r in results if r.get("status") == "PASS")
    good_count = sum(1 for r in results if r.get("status") == "GOOD")
    fail_count = sum(1 for r in results if r.get("status") == "FAIL")
    error_count = sum(1 for r in results if r.get("status") == "ERROR")

    valid_results = [r for r in results if r.get("diff_percent") is not None]
    if valid_results:
        avg_diff = sum(r["diff_percent"] for r in valid_results) / len(valid_results)
        max_diff = max(r["diff_percent"] for r in valid_results)
        min_diff = min(r["diff_percent"] for r in valid_results)

        logging.info(f"Samples tested: {len(results)}")
        logging.info(f"Perfect matches (<0.01%): {pass_count}/{len(results)}")
        logging.info(f"Very good (<0.1%): {good_count}/{len(results)}")
        logging.info(f"Failures (>0.1%): {fail_count}/{len(results)}")
        logging.info(f"Errors: {error_count}/{len(results)}")
        logging.info(f"\nAverage difference: {avg_diff:.6f}%")
        logging.info(f"Max difference: {max_diff:.6f}%")
        logging.info(f"Min difference: {min_diff:.6f}%")

        if avg_diff < 0.01:
            logging.info(
                "\n✅ RESULT: Library matches reference perfectly (<0.01% avg)"
            )
            sys.exit(0)
        elif avg_diff < 0.1:
            logging.info("\n✅ RESULT: Library very close to reference (<0.1% avg)")
            logging.info("   Investigate small differences to achieve <0.01%")
            sys.exit(0)
        else:
            logging.info(
                f"\n❌ RESULT: Library differs from reference ({avg_diff:.2f}% avg)"
            )
            logging.info("   Library extraction is INCORRECT - needs debugging")
            sys.exit(1)
    else:
        logging.error("No valid results to summarize")
        sys.exit(1)


if __name__ == "__main__":
    main()
